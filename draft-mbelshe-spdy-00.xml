<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0793 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml'>
  <!ENTITY RFC1738 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1738.xml'>
  <!ENTITY RFC1950 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1950.xml'>
  <!ENTITY RFC2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY RFC2285 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2285.xml'>
  <!ENTITY RFC2616 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'>
  <!ENTITY RFC2617 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml'>
  <!ENTITY RFC3986 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
  <!ENTITY RFC4559 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4559.xml'>
  <!ENTITY RFC4366 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml'>
  <!ENTITY RFC5246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml'>
  <!ENTITY RFC6454 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6454.xml'>
  <!ENTITY RFC6455 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6455.xml'>
  ]>

  <?xml-stylesheet type="text/xsl" href="rfc2629.xml"?>

  <?rfc toc="yes" symrefs="yes"?>

  <rfc ipr="trust200902" docName="draft-mbelshe-httpbis-spdy-00">
    <front>
      <title abbrev="SPDY">SPDY Protocol</title>
      <author initials="M." surname="Belshe" fullname="Mike Belshe">
        <organization>Twist</organization>
        <address>
          <email>mbelshe@chromium.org</email>
        </address>
      </author>
      <author initials="R." surname="Peon" fullname="Roberto Peon">
        <organization>Google, Inc</organization>
        <address>
          <email>fenix@google.com</email>
        </address>
      </author>
      <date month="August" year="2012" />
      <area>Applications</area>
      <keyword>HTTP</keyword>
      <abstract>
        <t>This document describes SPDY, a protocol designed for low-latency transport of content over the World Wide Web.  SPDY introduces two layers of protocol.  The lower layer is a general purpose framing layer which can be used atop a reliable transport (likely TCP) for multiplexed, prioritized, and compressed data communication of many concurrent streams.  The upper layer of the protocol provides HTTP-like semantics for compatibility with existing HTTP application servers.</t>
      </abstract>
    </front>

    <middle>
      <section anchor="intro" title="Overview">
        <t>One of the bottlenecks of HTTP implementations is that HTTP relies on multiple connections for concurrency. This causes several problems, including additional round trips for connection setup, slow-start delays, and connection rationing by the client, where it tries to avoid opening too many connections to any single server.  HTTP pipelining helps some, but only achieves partial multiplexing.  In addition, pipelining has proven non-deployable in existing browsers due to intermediary interference.</t>

        <t>SPDY adds a framing layer for multiplexing multiple, concurrent streams across a single TCP connection (or any reliable transport stream).  The framing layer is optimized for HTTP-like request-response streams, such that applications which run over HTTP today can work over SPDY with little or no change on behalf of the web application writer.</t>

        <t>The SPDY session offers four improvements over HTTP:
          <list>
            <t>Multiplexed requests: There is no limit to the number of requests that can be issued concurrently over a single SPDY connection.</t>
            <t>Prioritized requests: Clients can request certain resources to be delivered first.  This avoids the problem of congesting the network channel with non-critical resources when a high-priority request is pending.</t>
            <t>Compressed headers:  Clients today send a significant amount of redundant data in the form of HTTP headers.  Because a single web page may require 50 or 100 subrequests, this data is significant.</t>
            <t>Server pushed streams:  Server Push enables content to be pushed from servers to clients without a request.</t>
          </list>
        </t>

        <t>SPDY attempts to preserve the existing semantics of HTTP. All features such as cookies, ETags, Vary headers, Content-Encoding negotiations, etc work as they do with HTTP; SPDY only replaces the way the data is written to the network.</t>

        <section title="Document Organization">
          <t>The SPDY Specification is split into two parts: <xref target="FramingLayer">a framing layer</xref>, which multiplexes a TCP connection into independent, length-prefixed frames, and <xref target="HTTPLayer">an HTTP layer</xref>, which specifies the mechanism for overlaying HTTP request/response pairs on top of the framing layer. While some of the framing layer concepts are isolated from the HTTP layer, building a generic framing layer has not been a goal. The framing layer is tailored to the needs of the HTTP protocol and server push.</t>
        </section>
        <section title="Definitions">
          <t>
            <list>
              <t>client: The endpoint initiating the SPDY session.</t>
              <t>connection: A transport-level connection between two endpoints.</t>
              <t>endpoint: Either the client or server of a connection.</t>
              <t>frame: A header-prefixed sequence of bytes sent over a SPDY session.</t>
              <t>server: The endpoint which did not initiate the SPDY session.</t>
              <t>session: A synonym for a connection.</t>
              <t>session error: An error on the SPDY session.</t>
              <t>stream: A potentially bi-directional flow of bytes across a virtual channel within a SPDY session.</t>
              <t>stream error: An error on an individual SPDY stream.</t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="FramingLayer" title="SPDY Framing Layer">
        <section title="Session (Connections)">
          <t>The SPDY framing layer (or "session") runs atop a reliable transport layer such as <xref target="RFC0793">TCP</xref>. The client is the TCP connection initiator. SPDY connections are persistent connections.</t>

          <t>For best performance, it is expected that non-battery operated clients will leave open connections until the user navigates away from all web pages referencing the connection, or until the server closes the connection. Servers are encouraged to leave connections open for as long as possible, but can terminate idle connections if necessary.  When either endpoint closes the transport-level connection, it MUST first send a <xref target="GOAWAY">GOAWAY</xref> frame so that the endpoints can reliably determine if requests finished before the close. It is expected that battery-operated clients may have more involved heuristics as to when a connection should be closed.</t>
        </section>

        <section title="Framing">
          <t>Once the connection is established, clients and servers exchange framed messages.</t>

          <t>All frames carry a common set of headers: length, type, and flags. Flag definitions vary between frame types. The simple header format is designed to make reading and writing of frames easy.</t>

          <t>All integer values, including length, and type, are in network byte order.  SPDY does not enforce alignment of types in dynamically sized frames.</t>

          <section anchor="NotationalConventions" title="Notational Conventions for Framing">
            <t> In SPDY, since everything is defined to be in network byte-order, the most significant bit of any field is the "leftmost" in any diagram.
              <list>
                <t> "+" denotes the boundary of a byte (synonomous with octet in this document)</t>
                <t> "-" denotes a bit </t>
                <t> "=" denotes an unknown number of bits, typically bounded by one of the fields in the frame definition</t>
                <t> "|" denotes field separation, which may or may not be on a byte boundary. This does not count as a bit</t>
                <t> "-&gt;" at the end of a line indicates that the structure is not yet fully described</t>
                <t> "(N)" indicates that the field is N bits long</t>
                <t> "[Foo]" advises that the field is the Foo field for that frame</t>
                <t> "X" represents a reserved bit. It MUST be zeroed</t>
                <t> A number preceeded by "0x" is a hexidecimal number</t>
                <t> A number which is not preceeded by "0x" is to be interpreted as binary</t>
                <t> The numbers above the boxes indicate the byte-offset from the start of that frame or section, as appropriate</t>
              </list>
            </t>
            <t> As an example:
              <figure>
                <artwork>
                  0         1         2       3
                  +--|------+--|------+--------+--------+
                  |10|[PRI]0xEE|XXXXXX| Len(16)         |
                  +--|------+--|------+--------+--------+
                </artwork>
              </figure>
              This describes a frame which starts with 1 as the MSB, a 0 in the second most significant bit, followed by 0b11101110 (or 0xEE) as the "PRI" field, followed by 6 reserved bits, which will have all be zeroed, followed by a Len field which is 16 bits long.
              In other words, first two bytes would be: 0b10111011 0b10000000, followed by the Len field.
            </t>

            <t>
              Another example.  In this case, a single byte is represented with the most significant bit a 0, the second most significant bit a 1, the next bit the 'K' field, the next bit the 'L' field, and the next 4 bits are reserved and must be zeros. The frame description continues, describing that an indeterminate (presumably defined elsewhere) amount of data follows and ends on a byte boundary.
              <figure>
                <artwork>
                  0
                  +--|-|-|----+
                  |01|K|L|XXXX|  -&gt;
                  +--|-|-|----+

                  1..N
                  +========+
                  |  data  |
                  +========+
                </artwork>
              </figure>
            </t>
          </section>

          <section anchor="FrameFormat" title="Frame Format">
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+--------+--------+--------+--------+
  | Length(16)      |Type(8) |Flags(8)| Num-of-Entries-or-Stream-ID-or-ID | -&gt;
  +--------+--------+--------+--------+--------+--------+--------+--------+

  8..N
  +========+
  |  Data  |
  +========+
              </artwork>
            </figure>
            <t>Length: An unsigned 16-bit value representing the number of bytes of the data field.</t>

            <t>Type: The frame type. See <xref target="FrameTypes">Frame Types</xref> for the complete list of frames.</t>

            <t>Flags: Flags related to this frame. Flag definitions are dependent upon the frame type.</t>

            <t>Data: data associated with this control frame. The format of this data is controlled by the frame type.</t>

            <t>Frame processing requirements:
              <list>
                <t>Note that full length frames (64kb) can be large for implementations running on resource-limited hardware.  In such cases, implementations MAY limit the maximum length frame supported.  However, all implementations MUST be able to receive frames of at least 8192 octets in length.</t>
              </list>
            </t>
          </section>
        </section>

        <section title="Streams">
          <t>Streams are independent sequences of bi-directional data divided into frames with several properties:
            <list>
              <t>Streams may be created by either the client or server.</t>
              <t>Streams optionally carry a set of name/value header pairs.</t>
              <t>Streams can concurrently send data interleaved with other streams.</t>
              <t>Streams may be cancelled.</t>
            </list>
          </t>

          <section anchor="StreamFrames" title="Stream frames">
            <t>SPDY defines 3 control frames to manage the lifecycle of a stream:
              <list>
                <t>SYN_STREAM - Open a new stream</t>
                <t>SYN_REPLY - Remote acknowledgement of a new, open stream</t>
                <t>RST_STREAM - Close a stream</t>
              </list>
            </t>
          </section>

          <section anchor="StreamCreation" title="Stream creation">
            <t>A stream is created by sending a control frame with the type set to <xref target="SYN_STREAM">SYN_STREAM</xref>.  If the server is initiating the stream, the Stream-ID must be even.  If the client is initiating the stream, the Stream-ID must be odd.  0 is not a valid Stream-ID. Stream-IDs from each side of the connection must increase monotonically as new streams are created.  E.g. Stream 2 may be created after stream 3, but stream 7 must not be created after stream 9. Stream IDs do not wrap: when a client or server cannot create a new stream id without exceeding a 31 bit value, it MUST NOT create a new stream.</t>

            <t>The stream-id MUST increase with each new stream.  If an endpoint receives a SYN_STREAM with a stream id which is less than any previously received SYN_STREAM, it MUST issue a <xref target="SessionErrorHandler">session error</xref> with the status PROTOCOL_ERROR.</t>

            <t>It is a protocol error to send two SYN_STREAMs with the same stream-id.  If a recipient receives a second SYN_STREAM for the same stream, it MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the status code PROTOCOL_ERROR.</t>

            <t>Upon receipt of a SYN_STREAM, the recipient can reject the stream by sending a <xref target="StreamErrorHandler">stream error</xref> with the error code REFUSED_STREAM. Note, however, that the creating endpoint may have already sent additional frames for that stream which cannot be immediately stopped.</t>

            <t>Once the stream is created, the creator may immediately send HEADERS or DATA frames for that stream, without needing to wait for the recipient to acknowledge.</t>

            <section title="Unidirectional streams">
              <t>When an endpoint creates a stream that includes an Associated-To-Stream-ID, it creates a unidirectional stream which the creating endpoint can use to send frames, but the receiving endpoint cannot.  The receiving endpoint is implicitly already in the <xref target="StreamHalfClose">half-closed</xref> state.</t>
            </section>

            <section title="Bidirectional streams">
              <t>SYN_STREAM frames which do not include an Associated-To-Stream-ID are bidirectional streams.  Both endpoints can send data on a bi-directional stream.</t>
            </section>
          </section>

          <section anchor="StreamPriority" title="Stream priority">
            <t>The creator of a stream assigns a priority for that stream.  Priority is represented as an integer from 0 to 7.  0 represents the highest priority and 7 represents the lowest priority.</t>

            <t>The sender and recipient SHOULD use best-effort to process streams in the order of highest priority to lowest priority.</t>
          </section>

          <section title="Stream headers">
            <t>Streams carry optional sets of name/value pair headers which carry metadata about the stream.  After the stream has been created, and as long as the sender is not <xref target="StreamClose">closed</xref> or <xref target="StreamHalfClose">half-closed</xref>, each side may send HEADERS frame(s) containing the header data.  Header data can be sent in multiple HEADERS frames, and HEADERS frames may be interleaved with data frames.</t>
          </section>

          <section title="Stream data exchange">
            <t>Once a stream is created, it can be used to send arbitrary amounts of data.  Generally this means that a series of data frames will be sent on the stream until a frame containing the FLAG_FIN flag is set.  The FLAG_FIN can be set on a <xref target="SYN_STREAM">SYN_STREAM</xref>, <xref target="SYN_REPLY">SYN_REPLY</xref>, <xref target="HEADERS">HEADERS</xref> or a <xref target="DATA">DATA</xref> frame.  Once the FLAG_FIN has been sent, the stream is considered to be half-closed.</t>
          </section>

          <section anchor="StreamHalfClose" title="Stream half-close">
            <t>When one side of the stream sends a frame with the FLAG_FIN flag set, the stream is half-closed from that endpoint. The sender of the FLAG_FIN MUST NOT send further frames on that stream. When both sides have half-closed, the stream is closed.</t>

            <t>If an endpoint receives a data frame after the stream is half-closed from the sender (e.g. the endpoint has already received a prior frame for the stream with the FIN flag set), it MUST send a RST_STREAM to the sender with the status STREAM_ALREADY_CLOSED.</t>
          </section>

          <section anchor="StreamClose" title="Stream close">
            <t>There are 3 ways that streams can be terminated:
              <list>
                <t>Normal termination: Normal stream termination occurs when both sender and recipient have half-closed the stream by sending a FLAG_FIN.</t>
                <t>Abrupt termination: Either the client or server can send a RST_STREAM control frame at any time. A RST_STREAM contains an error code to indicate the reason for failure.  When a RST_STREAM is sent from the stream originator, it indicates a failure to complete the stream and that no further data will be sent on the stream.  When a RST_STREAM is sent from the stream recipient, the sender, upon receipt, should stop sending any data on the stream.  The stream recipient should be aware that there is a race between data already in transit from the sender and the time the RST_STREAM is received.  See <xref target="StreamErrorHandler">Stream Error Handling</xref></t>
                <t>TCP connection teardown: If the TCP connection is torn down while un-closed streams exist, then the endpoint must assume that the stream was abnormally interrupted and may be incomplete.</t>
              </list>
            </t>

            <t>If an endpoint receives a data frame after the stream is closed, it must send a RST_STREAM to the sender with the status PROTOCOL_ERROR.</t>
          </section>
        </section>

        <section title="Error Handling">
          <t>The SPDY framing layer has only two types of errors, and they are always handled consistently.  Any reference in this specification to "issue a session error" refers to <xref target="SessionErrorHandler"></xref>.  Any reference to "issue a stream error" refers to <xref target="StreamErrorHandler"></xref>.</t>

          <section anchor="SessionErrorHandler" title="Session Error Handling">
            <t>A session error is any error which prevents further processing of the framing layer or which corrupts the session compression state.  When a session error occurs, the endpoint encountering the error MAY send a <xref target="SETTINGS">SETTINGS</xref> frame. Whether or not a <xref target="SETTINGS">SETTINGS</xref> frame is sent, the endpoint encountering the error MUST send a <xref target="GOAWAY">GOAWAY</xref> frame with the stream id of most recently received stream from the remote endpoint, and the error code for why the session is terminating.  After sending the GOAWAY frame, the endpoint MUST close the TCP connection.</t>

            <t>Note that the session compression state is dependent upon both endpoints always processing all compressed data.  If an endpoint partially processes a frame containing compressed data without updating compression state properly, future control frames which use compression will be always be errored.  Implementations SHOULD always try to process compressed data so that errors which could be handled as stream errors do not become session errors.</t>

            <t>Note that because this GOAWAY is sent during a session error case, it is possible that the GOAWAY will not be reliably received by the receiving endpoint.  It is a best-effort attempt to communicate with the remote about why the session is going down.</t>
          </section>

          <section anchor="StreamErrorHandler" title="Stream Error Handling">
            <t>A stream error is an error related to a specific stream-id which does not affect processing of other streams at the framing layer.  Upon a stream error, the endpoint MUST send a <xref target="RST_STREAM">RST_STREAM</xref> frame which contains the stream id of the stream where the error occurred and the error status which caused the error.  After sending the RST_STREAM, the stream is closed to the sending endpoint.  After sending the RST_STREAM, if the sender receives any frames other than a RST_STREAM for that stream id, it will result in sending additional RST_STREAM frames.  An endpoint MUST NOT send a RST_STREAM in response to an RST_STREAM, as doing so would lead to RST_STREAM loops.  Sending a RST_STREAM does not cause the SPDY session to be closed.</t>

            <t>If an endpoint has multiple RST_STREAM frames to send in succession for the same stream-id and the same error code, it MAY coalesce them into a single RST_STREAM frame.  (This can happen if a stream is closed, but the remote sends multiple data frames.  There is no reason to send a RST_STREAM for each frame in succession).</t>
          </section>
        </section>

        <section title="Data flow">
          <t>Because TCP provides a single stream of data on which SPDY multiplexes multiple logical streams, clients and servers must intelligently interleave data messages for concurrent sessions.</t>
        </section>

        <section anchor="FrameTypes" title="Frame Types">
          <texttable align='left'>
            <ttcol align='center'>Type-field value</ttcol>
            <ttcol align='center'>Frame type</ttcol>
            <c> 0x0</c> <c> <xref target="DATA">DATA</xref></c>
            <c> 0x1</c> <c> <xref target="SYN_STREAM">SYN_STREAM</xref></c>
            <c> 0x2</c> <c> <xref target="SYN_REPLY">SYN_REPLY</xref></c>
            <c> 0x3</c> <c> <xref target="RST_STREAM">RST_STREAM</xref></c>
            <c> 0x5</c> <c> <xref target="PUSH_PROMISE">PUSH_PROMISE</xref></c>
            <c> 0x4</c> <c> <xref target="SETTINGS">SETTINGS</xref></c>
            <c> 0x6</c> <c> <xref target="PING">PING</xref></c>
            <c> 0x7</c> <c> <xref target="GOAWAY">GOAWAY</xref></c>
            <c> 0x8</c> <c> <xref target="HEADERS">HEADERS</xref></c>
            <c> 0x9</c> <c> <xref target="WINDOW_UPDATE">WINDOW_UPDATE</xref></c>
            <c> 0xa</c> <c> <xref target="CREDENTIAL">CREDENTIAL</xref></c>
          </texttable>
          <t> Shared components of several control frames: <xref target="HeaderBlock">Name/Value Header Block</xref></t>

          <section anchor="DATA" title="DATA">
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x0 |Flags(8)|X| Stream-ID(31)                    | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8..N
  +========+
  |  Data  |
  +========+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  The total size of a data frame is 8 bytes + length. It is valid to have a zero-length data frame.</t>

            <t>Flags: Flags related to this frame. Valid flags are:
              <list>
                <t>0x01 = FLAG_FIN - signifies that this frame represents the last frame to be transmitted on this stream.  See <xref target="StreamClose">Stream Close</xref> below.</t>
                <t>0x02 = MSG_DONE - signifies that this frame represents the last frame of a message.  This is relevant for layering of message-based protocols on top of SPDY.</t>
              </list>
            </t>

            <t>Stream-ID: A 31-bit value identifying the stream.</t>

            <t>Data: The variable-length data payload; the length was defined in the length field.</t>

            <t>Data frame processing requirements:
              <list>
                <t>If an endpoint receives a data frame for a stream-id which is not open and the endpoint has not sent a <xref target="GOAWAY">GOAWAY</xref> frame, it MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the error code INVALID_STREAM for the stream-id.</t>
                <t>If the endpoint which created the stream receives a data frame before receiving a SYN_REPLY on that stream, it is a protocol error, and the recipient MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the status code PROTOCOL_ERROR for the stream-id.</t>
                <t>Implementors note: If an endpoint receives multiple data frames for invalid stream-ids, it MAY close the session.</t>
              </list>
            </t>
          </section>

          <section anchor="SYN_STREAM" title="SYN_STREAM">
            <t>The SYN_STREAM control frame allows the sender to asynchronously create a stream between the endpoints.  See <xref target="StreamCreation">Stream Creation</xref></t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x1 |Flags(8)|X| Stream-ID(31)                    | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8        9        10       11       12,13,14..N
  +-|-------+--------+--------+--------+=========================+
  |X|Priority(31)                      | Name/Value Header Block |
  +-|-------+--------+--------+--------+=========================+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  For SYN_STREAM frames, this is 4 bytes plus the length of the Name/Value Header Block.</t>

            <t>Flags: Flags related to this frame. Valid flags are:
              <list>
                <t>0x01 = FLAG_FIN - marks this frame as the last frame to be transmitted on this stream and puts the sender in the <xref target="StreamHalfClose">half-closed</xref> state.</t>
              </list>
            </t>

            <t>Stream-ID: The 31-bit identifier for this stream.  This stream-id will be used in frames which are part of this stream.</t>

            <t>Priority: A 31-bit <xref target="StreamPriority">priority</xref> field.</t>

            <t>Name/Value Header Block: A set of name/value pairs carried as part of the SYN_STREAM. <xref target="HeaderBlock">see Name/Value Header Block</xref>.</t>

            <t>If an endpoint receives a SYN_STREAM which is larger than the implementation supports, it MAY send a RST_STREAM with error code FRAME_TOO_LARGE.  All implementations MUST support the minimum size limits defined in <xref target="FrameFormat">the Frame Format section</xref>.</t>

          </section>

          <section anchor="SYN_REPLY" title="SYN_REPLY">
            <t>SYN_REPLY indicates the acceptance of a stream creation by the recipient of a SYN_STREAM frame.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x2 |Flags(8)|X| Stream-ID(31)                    | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8,9,10..N
  +=========================+
  | Name/Value Header Block |
  +=========================+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header. For SYN_REPLY frames, this is the length of the Name/Value Header Block.</t>

            <t>Flags: Flags related to this frame. Valid flags are:
              <list>
                <t>0x01 = FLAG_FIN - marks this frame as the last frame to be transmitted on this stream and puts the sender in the <xref target="StreamHalfClose">half-closed</xref> state.</t>
              </list>
            </t>

            <t>Stream-ID: The 31-bit identifier for this stream.</t>

            <t>If an endpoint receives multiple SYN_REPLY frames for the same active stream ID, it MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the error code STREAM_IN_USE.</t>

            <t>Name/Value Header Block: A set of name/value pairs carried as part of the SYN_REPLY. <xref target="HeaderBlock">see Name/Value Header Block</xref>.</t>

            <t>If an endpoint receives a SYN_REPLY which is larger than the implementation supports, it MAY send a RST_STREAM with error code FRAME_TOO_LARGE.  All implementations MUST support the minimum size limits defined in <xref target="FrameFormat">the Frame Format section</xref>.</t>
          </section>

          <section anchor="RST_STREAM" title="RST_STREAM">
            <t>The RST_STREAM frame allows for abnormal termination of a stream.  When sent by the creator of a stream, it indicates the creator wishes to cancel the stream.  When sent by the recipient of a stream, it indicates an error or that the recipient did not want to accept the stream, so the stream should be closed.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x3 |Flags(8)|X| Stream-ID(31)                    | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8        9        10       11
  +--------+--------+--------+--------+
  | Status-Code(32)                   |
  +--------+--------+--------+--------+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header. For RST_STREAM frames, this value is always 4.</t>

            <t>Flags: Flags related to this frame. RST_STREAM does not define any flags.  This value must be 0.</t>

            <t>Stream-ID: The 31-bit identifier for this stream.</t>

            <t>Status code: (32 bits) An indicator for why the stream is being terminated.The following status codes are defined:
              <list>
                <t>1 - PROTOCOL_ERROR. This is a generic error, and should only be used if a more specific error is not available.</t>
                <t>2 - INVALID_STREAM. This is returned when a frame is received for a stream which is not active.</t>
                <t>3 - REFUSED_STREAM.  Indicates that the stream was refused before any processing has been done on the stream.</t>
                <t>4 - UNSUPPORTED_VERSION.  Indicates that the recipient of a stream does not support the SPDY version requested.</t>
                <t>5 - CANCEL.  Used by the creator of a stream to indicate that the stream is no longer needed.</t>
                <t>6 - INTERNAL_ERROR.  This is a generic error which can be used when the implementation has internally failed, not due to anything in the protocol.</t>
                <t>7 - FLOW_CONTROL_ERROR.  The endpoint detected that its peer violated the flow control protocol.</t>
                <t>8 - STREAM_IN_USE.  The endpoint received a SYN_REPLY for a stream already open.</t>
                <t>9 - STREAM_ALREADY_CLOSED.  The endpoint received a data or SYN_REPLY frame for a stream which is half closed.</t>
                <t>10 - INVALID_CREDENTIALS.  The server received a request for a resource whose origin does not have valid credentials in the client certificate vector.</t>
                <t>11 - FRAME_TOO_LARGE.  The endpoint received a frame which this implementation could not support.  If FRAME_TOO_LARGE is sent for a SYN_STREAM, HEADERS, or SYN_REPLY frame without fully processing the compressed portion of those frames, then the compression state will be out-of-sync with the other endpoint.  In this case, senders of FRAME_TOO_LARGE MUST close the session.</t>
                <t>Note:  0 is not a valid status code for a RST_STREAM.</t>
              </list>
            </t>

            <t>After receiving a RST_STREAM on a stream, the recipient must not send additional frames for that stream, and the stream moves into the closed state.</t>
          </section>

          <section anchor="PUSH_PROMISE" title="PUSH_PROMISE">
            <t>The PUSH_PROMISE control frame allows the sender to signal a promise to create a stream and serve the referenced resource. Minimal data allowing the receiver to understand which resource(s) are to be pushed are to be included.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x5 |Flags(8)|X| Associated-To-Stream-ID(31)      | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8        9        10       11       12,13,14..N
  +-|-------+--------+--------+--------+=========================+
  |X| Promised-Stream-ID(31)           | Name/Value Header Block |
  +-|-------+--------+--------+--------+=========================+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  For PUSH_PROMISE frames, this is 4 bytes plus the length of the Name/Value Header Block.</t>

            <t>Flags: Flags related to this frame. Valid flags are:
              <list>
                <t>0x01 = FLAG_FIN - marks this frame as the last frame to be transmitted on this stream and puts the sender in the <xref target="StreamHalfClose">half-closed</xref> state.</t>
              </list>
            </t>

            <t>Associated-To-Stream-ID: The 31-bit identifier for a stream which this stream is associated to.  If this stream is independent of all other streams, it should be 0.</t>

            <t>Promised-Stream-ID: The 31-bit identifier indicating the stream-id on which the resource will be pushed. If multiple headers are indicated within the Name/Value Header Block, each subsequent resource as indicated in the Header Block will increment the Promised-Stream-Id by two. The Promised-Stream-ID is subject to the same rules as any other stream-id-- when defined and transmitted, the Promised-Stream-ID MUST be part of a monotonically increasing sequence of stream-ids. There is no requirement that the streams referred to by the this frame are created in the order referenced.</t>

            <t>Name/Value Header Block:  A set of name/value pairs carried as part of the PUSH_PROMISE.  <xref target="HeaderBlock">see Name/Value Header Block</xref>.</t>

            <t>If an endpoint receives a PUSH_PROMISE which is larger than the implementation supports, it MAY send a RST_STREAM with error code FRAME_TOO_LARGE.  All implementations MUST support the minimum size limits defined in <xref target="FrameFormat">the Frame Format section</xref>.</t>

          </section>

          <section anchor="SETTINGS" title="SETTINGS">
            <t>A SETTINGS frame contains a set of id/value pairs for communicating configuration data about how the two endpoints may communicate. SETTINGS frames can be sent at any time by either endpoint, are optionally sent, and are fully asynchronous.  When the server is the sender, the sender can request that configuration data be persisted by the client across SPDY sessions and returned to the server in future communications.</t>

            <t>Persistence of SETTINGS ID/Value pairs is done on a per origin/IP pair (the "origin" is the set of scheme, host, and port from the URI.  See <xref target="RFC6454"></xref>).  That is, when a client connects to a server, and the server persists settings within the client, the client SHOULD return the persisted settings on future connections to the same origin AND IP address and TCP port. Clients MUST NOT request servers to use the persistence features of the SETTINGS frames, and servers MUST ignore persistence related flags sent by a client.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x4 |Flags(8)|X|Number-of-Entries(31)             | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8..N
  +================+
  | ID/Value-Pairs |
  +================+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  For SETTINGS frames, this is the length of the ID/Value-Pairs Block.</t>

            <t>Type: The message type for a SETTINGS message is 4.</t>

            <t>Flags: FLAG_SETTINGS_CLEAR_SETTINGS (0x1): When set, the client should clear any previously persisted SETTINGS ID/Value pairs.  If this frame contains ID/Value pairs with the FLAG_SETTINGS_PERSIST_VALUE set, then the client will first clear its existing, persisted settings, and then persist the values with the flag set which are contained within this frame.  Because persistence is only implemented on the client, this flag can only be used when the sender is the server.</t>

            <t>Number of entries: A 32-bit value representing the number of ID/value pairs in this message. </t>

            <t>Each ID/value pair is as follows:
              <figure>
                <artwork>
                  0        1        2        3        4        5        6        7
                  +--------+--------+--------+--------+--------+--------+--------+--------+
                  |Flags(8)| ID(24)                   | Value(32)                         |
                  +--------+--------+--------+--------+--------+--------+--------+--------+
                </artwork>
              </figure>
            </t>

            <t>Flags: An 8 bit value.  Defined Flags:
              <list>
                <t>FLAG_SETTINGS_PERSIST_VALUE (0x1):   When set, the sender of this SETTINGS frame is requesting that the recipient persist the ID/Value and return it in future SETTINGS frames sent from the sender to this recipient.  Because persistence is only implemented on the client, this flag is only sent by the server.</t>
                <t>FLAG_SETTINGS_PERSISTED (0x2):  When set, the sender is notifying the recipient that this ID/Value pair was previously sent to the sender by the recipient with the FLAG_SETTINGS_PERSIST_VALUE, and the sender is returning it.  Because persistence is only implemented on the client, this flag is only sent by the client.</t>
              </list>
            </t>

            <t>ID: 24-bits in network byte order.  Defined IDs:
              <list>
                <t>1 - SETTINGS_UPLOAD_BANDWIDTH allows the sender to send its expected upload bandwidth on this channel. This number is an estimate. The value should be the integral number of kilobytes per second that the sender predicts as an expected maximum upload channel capacity.</t>
                <t>2 - SETTINGS_DOWNLOAD_BANDWIDTH allows the sender to send its expected download bandwidth on this channel. This number is an estimate. The value should be the integral number of kilobytes per second that the sender predicts as an expected maximum download channel capacity.</t>
                <t>3 - SETTINGS_ROUND_TRIP_TIME allows the sender to send its expected round-trip-time on this channel. The round trip time is defined as the minimum amount of time to send a control frame from this client to the remote and receive a response. The value is represented in milliseconds.</t>
                <t>4 - SETTINGS_MAX_CONCURRENT_STREAMS allows the sender to inform the remote endpoint the maximum number of concurrent streams which it will allow. By default there is no limit. For implementors it is recommended that this value be no smaller than 100.</t>
                <t>5 - SETTINGS_CURRENT_CWND allows the sender to inform the remote endpoint of the current TCP CWND value.</t>
                <t>6 - SETTINGS_DOWNLOAD_RETRANS_RATE allows the sender to inform the remote endpoint the retransmission rate (bytes retransmitted / total bytes transmitted).</t>
                <t>7 - SETTINGS_INITIAL_WINDOW_SIZE allows the sender to inform the remote endpoint the initial window size (in bytes) for new streams.</t>
                <t>8 - SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE allows the server to inform the client if the new size of the client certificate vector.</t>
                <t>9 - SETTINGS_SUPPORTING_SCHEMES allows the sender to inform the remote endpoint supporting overlayering protocol schemes. The corresponding value must be a 32-bit value, and which contains flags as follows:</t>
                <list>
                  <t>bit 0: http</t>
                  <t>bit 1: https</t>
                  <t>bit 2: ws</t>
                  <t>bit 3: wss</t>
                </list>
              </list>
            </t>

            <t>Value: A 32-bit value.</t>

            <t>The message is intentionally extensible for future information which may improve client-server communications. The sender does not need to send every type of ID/value. It must only send those for which it has accurate values to convey. When multiple ID/value pairs are sent, they should be sent in order of lowest id to highest id.  A single SETTINGS frame MUST not contain multiple values for the same ID.  If the recipient of a SETTINGS frame discovers multiple values for the same ID, it MUST ignore all values except the first one.</t>

            <t>A server may send multiple SETTINGS frames containing different ID/Value pairs.  When the same ID/Value is sent twice, the most recent value overrides any previously sent values.  If the server sends IDs 1, 2, and 3 with the FLAG_SETTINGS_PERSIST_VALUE in a first SETTINGS frame, and then sends IDs 4 and 5 with the FLAG_SETTINGS_PERSIST_VALUE, when the client returns the persisted state on its next SETTINGS frame, it SHOULD send all 5 settings (1, 2, 3, 4, and 5 in this example) to the server.</t>
          </section>

          <section anchor="PING" title="PING">
            <t>The PING control frame is a mechanism for measuring a minimal round-trip time from the sender.  It can be sent from the client or the server.  Recipients of a PING frame should send an identical frame to the sender as soon as possible (if there is other pending data waiting to be sent, PING should take highest priority).  Each ping sent by a sender should use a unique ID.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x6 |XXXXXXXX|X| ID(31)                           |
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  For PING frames, this value is always 0.</t>

            <t>ID: A unique ID for this ping, represented as an unsigned 32 bit value.  When the client initiates a ping, it must use an odd numbered ID.  When the server initiates a ping, it must use an even numbered ping.  Use of odd/even IDs is required in order to avoid accidental looping on PINGs (where each side initiates an identical PING at the same time).</t>

            <t>Note: If a sender uses all possible PING ids (e.g. has sent all 2^31 possible IDs), it can wrap and start re-using IDs.</t>

            <t>If a server receives an even numbered PING which it did not initiate, it must ignore the PING.
              If a client receives an odd numbered PING which it did not initiate, it must ignore the PING.</t>
          </section>

          <section anchor="GOAWAY" title="GOAWAY">
            <t>The GOAWAY control frame is a mechanism to tell the remote side of the connection to stop creating streams on this session.  It can be sent from the client or the server. Once sent, the sender will not respond to any new SYN_STREAMs on this session. Recipients of a GOAWAY frame must not send additional streams on this session, although a new session can be established for new streams.  The purpose of this message is to allow an endpoint to gracefully stop accepting new streams (perhaps for a reboot or maintenance), while still finishing processing of previously established streams.</t>

            <t>There is an inherent race condition between an endpoint sending SYN_STREAMs and the remote sending a GOAWAY message.  To deal with this case, the GOAWAY contains a last-stream-id indicating the stream-id of the last stream which was created on the sending endpoint in this session.  If the receiver of the GOAWAY sent new SYN_STREAMs for sessions after this last-stream-id, they were not processed by the server and the receiver may treat the stream as though it had never been created at all (hence the receiver may want to re-create the stream later on a new session).</t>

            <t>Endpoints should always send a GOAWAY message before closing a connection so that the remote can know whether a stream has been partially processed or not.  (For example, if an HTTP client sends a POST at the same time that a server closes a connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate where it stopped working).</t>

            <t>After sending a GOAWAY message, the sender must ignore all SYN_STREAM frames for new streams.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7     
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x7 |Flags(8)|X| Last-Good-Stream-ID(31)          | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8        9        10       11
  +--------+--------+--------+--------+
  |          Status-Code(32)          |
  +--------+--------+--------+--------+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  For PING frames, this value is always 4.</t>

            <t>Last-good-stream-Id: The last stream id which was replied to (with either a SYN_REPLY or RST_STREAM) by the sender of the GOAWAY message.  If no streams were replied to, this value MUST be 0.</t>

            <t>Status: The reason for closing the session.
              <list>
                <t>0 - OK. This is a normal session teardown.</t>
                <t>1 - PROTOCOL_ERROR. This is a generic error, and should only be used if a more specific error is not available.</t>
                <t>2 - INTERNAL_ERROR. This is a generic error which can be used when the implementation has internally failed, not due to anything in the protocol.</t>
              </list>
            </t>
          </section>

          <section anchor="HEADERS" title="HEADERS">
            <t> The HEADERS frame augments a group of streams or an individual stream with additional metadata by providing an opportunity to send a new <xref target="HeaderBlock">Name/Value Header Block</xref> associated with the stream</t>
            <t> Please see <xref target="HeaderBlock">Name/Value Header Block</xref> for further details about how it is to be interpreted.</t>
            <t>Here is the format of a headers frame and headers block:</t>
            <figure>
              <artwork>
  0        1        2        3         4        5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x8 |Flags(8)|X| Stream-ID(31)                    | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8,9,10..N
  +=========================+
  | Name/Value Header Block |
  +=========================+
              </artwork>
            </figure>

            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header. For HEADERS frames, this is the length of the Name/Value Header Block.</t>

            <t>Flags: Flags related to this frame. Valid flags are:
              <list>
                <t>0x01 = FLAG_FIN - marks this frame as the last frame to be transmitted on this stream and puts the sender in the <xref target="StreamHalfClose">half-closed</xref> state.</t>
                <t>0x02 = FLAG_HEADER_END - marks this frame as the end of the current header. Multiple HEADERS frames may be involved in constructing a single header, if it is sufficiently large.</t>
              </list>
            </t>

            <t>Length: An unsigned 24 bit value representing the number of bytes after the length field. The minimum length of the length field is 7 (when the number of name value pairs is 0).</t>

            <t>Stream-ID: The stream this HEADERS block is associated with.</t>

            <t>Name/Value Header Block:  A set of name/value pairs carried as part of the SYN_STREAM.  <xref target="HeaderBlock">see Name/Value Header Block</xref>.</t>

          </section>

          <section anchor="WINDOW_UPDATE" title="WINDOW_UPDATE">
            <t>The WINDOW_UPDATE control frame is used to implement per stream flow control in SPDY. Flow control in SPDY is per hop, that is, only between the two endpoints of a SPDY connection. If there are one or more intermediaries between the client and the origin server, flow control signals are not explicitly forwarded by the intermediaries. (However, throttling of data transfer by any recipient may have the effect of indirectly propagating flow control information upstream back to the original sender.) Flow control only applies to the data portion of data frames. Recipients must buffer all control frames. If a recipient fails to buffer an entire control frame, it MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the status code FLOW_CONTROL_ERROR for the stream.</t>

            <t>Flow control in SPDY is implemented by a data transfer window kept by the sender of each stream. The data transfer window is a simple uint32 that indicates how many bytes of data the sender can transmit. After a stream is created, but before any data frames have been transmitted, the sender begins with the initial window size. This window size is a measure of the buffering capability of the recipient. The sender must not send a data frame with data length greater than the transfer window size. After sending each data frame, the sender decrements its transfer window size by the amount of data transmitted. When the window size becomes less than or equal to 0, the sender must pause transmitting data frames. At the other end of the stream, the recipient sends a WINDOW_UPDATE control back to notify the sender that it has consumed some data and freed up buffer space to receive more data.</t>
            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0x9 |Flags(8)|X| Stream-ID(31)                    | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8        9        10       11
  +--------+--------+--------+--------+
  |Delta-Window-Size                  |
  +--------+--------+--------+--------+
              </artwork>
            </figure>
            <t>Length: An unsigned 16-bit value representing the number of bytes which follow the frame header.  For WINDOW_UPDATE frames, this value is always 4.</t>

            <t>Stream-ID: The stream ID that this WINDOW_UPDATE control frame is for.</t>

            <t>Delta-Window-Size: The additional number of bytes that the sender can transmit in addition to existing remaining window size. The legal range for this field is 1 to 2^31 - 1 (0x7fffffff) bytes.</t>

            <t>The window size as kept by the sender must never exceed 2^31 (although it can become negative in one special case). If a sender receives a WINDOW_UPDATE that causes the its window size to exceed this limit, it must send RST_STREAM with status code FLOW_CONTROL_ERROR to terminate the stream.</t>

            <t>When a SPDY connection is first established, the default initial window size for all streams is 64KB. An endpoint can use the SETTINGS control frame to adjust the initial window size for the connection. That is, its peer can start out using the 64KB default initial window size when sending data frames before receiving the SETTINGS. Because SETTINGS  is asynchronous, there may be a race condition if the recipient wants to decrease the initial window size, but its peer immediately sends 64KB on the creation of a new connection, before waiting for the SETTINGS to arrive. This is one case where the window size kept by the sender will become negative. Once the sender detects this condition, it must stop sending data frames and wait for the recipient to catch up. The recipient has two choices:
              <list>
                <t>immediately send RST_STREAM with FLOW_CONTROL_ERROR status code.</t>
                <t>allow the head of line blocking (as there is only one stream for the session and the amount of data in flight is bounded by the default initial window size), and send WINDOW_UPDATE as it consumes data.</t>
              </list>
            </t>

            <t>In the case of option 2, both sides must compute the window size based on the initial window size in the SETTINGS. For example, if the recipient sets the initial window size to be 16KB, and the sender sends 64KB immediately on connection establishment, the sender will discover its window size is -48KB on receipt of the SETTINGS. As the recipient consumes the first 16KB, it must send a WINDOW_UPDATE of 16KB back to the sender. This interaction continues until the sender's window size becomes positive again, and it can resume transmitting data frames.</t>

            <t>After the recipient reads in a data frame with FLAG_FIN that marks the end of the data stream, it should not send WINDOW_UPDATE frames as it consumes the last data frame. A sender should ignore all the WINDOW_UPDATE frames associated with the stream after it send the last frame for the stream.</t>

            <t>The data frames from the sender and the WINDOW_UPDATE frames from the recipient are completely asynchronous with respect to each other. This property allows a recipient to aggressively update the window size kept by the sender to prevent the stream from stalling.</t>
          </section>

          <section anchor="CREDENTIAL" title="CREDENTIAL">
            <t>The CREDENTIAL control frame is used by the client to send additional client certificates to the server.  A SPDY client may decide to send requests for resources from different origins on the same SPDY session if it decides that that server handles both origins.  For example if the IP address associated with both hostnames matches and the SSL server certificate presented in the initial handshake is valid for both hostnames.  However, because the SSL connection can contain at most one client certificate, the client needs a mechanism to send additional client certificates to the server.</t>

            <t>The server is required to maintain a vector of client certificates associated with a SPDY session.  When the client needs to send a client certificate to the server, it will send a CREDENTIAL frame that specifies the index of the slot in which to store the certificate as well as proof that the client posesses the corresponding private key.  The initial size of this vector must be 8.  If the client provides a client certificate during the first TLS handshake, the contents of this certificate must be copied into the first slot (index 1) in the CREDENTIAL vector, though it may be overwritten by subsequent CREDENTIAL frames.  The server must exclusively use the CREDENTIAL vector when evaluating the client certificates associated with an origin.  The server may change the size of this vector by sending a SETTINGS frame with the setting SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE value specified.  In the event that the new size is smaller than the current size, truncation occurs preserving lower-index slots as possible.</t>  

            <t>TLS renegotiation with client authentication is incompatible with SPDY given the multiplexed nature of SPDY.  Specifically, imagine that the client has 2 requests outstanding to the server for two different pages (in different tabs).  When the renegotiation + client certificate request comes in, the browser is unable to determine which resource triggered the client certificate request, in order to prompt the user accordingly.</t>

            <figure>
              <artwork>
  0        1        2        3        4         5        6        7
  +--------+--------+--------+--------+-|-------+--------+--------+--------+
  | Length(16)      |    0xa |Flags(8)|X| Num-of-Entires(31)               | -&gt;
  +--------+--------+--------+--------+-|-------+--------+--------+--------+

  8        9        10       11        12
  +--------+--------+--------+--------+========+
  | Slot(16)        |Proof Length(16) | Proof  | -&gt;
  +--------+--------+--------+--------+========+

  /--Repeated to frame end--\
  +--------+--------+========+
  | Cert Length(16) | Cert   |
  +--------+--------+========+
              </artwork>
            </figure>

            <t>Slot: The index in the server's client certificate vector where this certificate should be stored.  If there is already a certificate stored at this index, it will be overwritten.  The index is one based, not zero based; zero is an invalid slot index.</t>
            <t>Proof: Cryptographic proof that the client has possession of the private key associated with the certificate.  The format is a TLS digitally-signed element (http://tools.ietf.org/html/rfc5246#section-4.7).  The signature algorithm must be the same as that used in the CertificateVerify message.  However, since the MD5+SHA1 signature type used in TLS 1.0 connections can not be correctly encoded in a digitally-signed element, SHA1 must be used when MD5+SHA1 was used in the SSL connection.  The signature is calculated over a 32 byte TLS extractor value (http://tools.ietf.org/html/rfc5705) with a label of "EXPORTER SPDY certificate proof" using the empty string as context. ForRSA certificates the signature would be a PKCS#1 v1.5 signature. For ECDSA, it would be an ECDSA-Sig-Value (http://tools.ietf.org/html/rfc5480#appendix-A).  For a 1024-bit RSA key, the CREDENTIAL message would be ~500 bytes.</t>
            <t>Certificate: The certificate chain, starting with the leaf certificate.  Each certificate must be encoded as a 32 bit length, followed by a DER encoded certificate.  The certificate must be of the same type (RSA, ECDSA, etc) as the client certificate associated with the SSL connection.</t>
            <t>If the server receives a request for a resource with unacceptable credential (either missing or invalid), it must reply with a RST_STREAM frame with the status code INVALID_CREDENTIALS. Upon receipt of a RST_STREAM frame with INVALID_CREDENTIALS, the client should initiate a new stream directly to the requested origin and resend the request.  Note, SPDY does not allow the server to request different client authentication for different resources in the same origin.</t>
            <t>If the server receives an invalid CREDENTIAL frame, it MUST respond with a GOAWAY frame and shutdown the session.  </t>
          </section>

          <section anchor="HeaderBlock" title="Name/Value Header Block">

            <t>A Name/Value Header Block augments the streams or group of streams identified by the <xref target="SYN_STREAM">SYN_STREAM</xref>, <xref target="HEADERS">HEADERS</xref>, or <xref target="SYN_REPLY">SYN_REPLY</xref> frame stream with additional metadata.
            </t>

            <t>
              At the group level, a map of token-index to key-pair is maintained for each defined group. There is no persistent mapping from stream-id to header-group, instead each HeaderBlock includes reference to the HeaderGroup that will be used in this particular set of metadata.
            </t>

            <t>The HeaderBlock compressor (described later) is subject to the following constraints:
              <list>
                <t>TotalHeaderStorageSize :  default(16k)</t>
                <t>MaxHeaderGroups: default(1)</t>
                <t>MaxValEntries: default(64)</t>
              </list>
            </t>

            <t> It is expected that either party will set these to larger values immediately upon connection establishment using the SETTINGS frame.</t>

            <t> A stream with a HeaderBlock which declares that it is using HeaderGroup 'G' would use the following algorithm to interpret its meta-data.</t>

            <figure>
              <artwork>
                def compute_headers(stream):
                headers = {}
                for index in stream_group[G]:
                headers[lru_lookup[index].key] = lru_lookup[index].val)
                for {key, value} in ephemereal_headers_from_HeaderBlock:
                headers[key] = value
                return headers
              </artwork>
            </figure>

            <t>A smart implementation will be able to interpret a headers frame without reconstructing the headers, and thus be able to represent and interpret headers with less memory and CPU.</t>

            <t>The Name/Value Header Block is found in the SYN_STREAM, SYN_REPLY
              and HEADERS control frames, and shares a common format:</t>
            <figure>
              <artwork>
                0        1        2          3..N       N+1..K
                +--------+--------+--------+=====+     +=====+
                | HG(8)  | next-lru-seq-num| Ops | ... | Ops |
                +--------+--------+--------+=====+     +=====+
              </artwork>
            </figure>

            <t>Ops are of the form:
              <figure>
                <artwork>
                  +--------+--------+=========+
                  | OpCode | NumOps | Op Args |
                  +--------+--------+=========+
                </artwork>
              </figure>
            </t>

            <t>HG: (Header Group) An 8 bit unsigned integer specifying the header group for this set of headers.</t>
            <t>Ops: A number of operations. Operations will be detailed below.</t>

            <t>
              The Opcode field indicates the type of operation.
              <list>
                <t>0x0 (reserved) -- this is not used and is reserved in case a token-based delimiter is required in the future.</t>
                <t>0x1 (Toggle) indicates that the data which follows will be an lru-index. That lru-index, if present in the current header-group will be removed from the header group. If it is not present in the current header group, it will be added to the current header group. This opcode thus affects what parts of the data stored in the LRU are interpreted as being visible in the current set of headers for whatever frame includes the HeaderBlock</t>
                <t>0x1 (Clone) indicates that the data which follows will be a key-index and a string literal. The key-index is used to refer to a pre-existing key, and thus the operation results in the storing of the pre-existing key and the new value. The key-value will be appended to the LRU, and the index in the LRU added to the current header group.</t>
                <t>0x2 (KVSto) indicates that the data which follows will be two string literals. The first such string represents a new key to be stored, and the second such string represents a value. As with Clone, the key-value will be stored in the LRU with a new index, and that index will be added to the current header group.</t>
                <t>0x2 (Eref)  indicates that the data which follows will be two string literals. The first such string represents key, and the second string represents a value. Unlike KVSto, the Eref does not modify the compressor state-- it only specified a key-value which will be interpreted as being part of the meta-data for the frame which includes the HeaderBlock.</t>
              </list>
            </t>

            <t> String are always encoded as a single bit, followed by data. If that bit is '0', then what follows is 7-bit us-ascii, null-terminated. If that bit is '1', then it is huffman encoded using a canonical huffman-code and ends with an 'eof' character (which is not part of the string). If the last bit of the EOF is not immediately before the byte boundary, the remaining bits of that byte are padded with zero. Strings in a request are encoded with a different huffman-encoder than strings in a response, as the frequency of occurance in these differ by quite a bit.
              <figure>
                <artwork>
                  A string is either:
                  +-|============================|====================|--------+
                  |1| huffman-encoded-characters | huffman-eof-symbol |pad-bits|
                  +-|============================|====================|--------+

                  or

                  +-|-------+========+--------+
                  |0|  7 bit-ascii   |00000000|
                  +-|-------+========+--------+
                </artwork>
              </figure>
            </t>

            <t>
              The NumOps field encodes one minus the number of operations that follow. Since the field-width is 8 bits, a maximum of 256 ops can be represented. If more than 256 operations are required, simply repeat doing this until all operations have been encoded. It is expected that this will be extremely rare.
            </t>

            <t>
              Detail of an operation with an opcode of 0x1 (Toggle):

              <figure>
                <artwork>
                  0        1
                  +--------+--------+
                  |00000001| NumOps |
                  +--------+--------+


                  repeated NumOps times
                    ______/ \______
                   /               \

                  +--------+--------+
                  | LRU idx(16)     |
                  +--------+--------+
                </artwork>
              </figure>
            </t>

            <t>
              Detail of an operation with an opcode of 0x2 (Clone):

              <figure>
                <artwork>
                  0        1
                  +--------+--------+
                  |00000010| NumOps |
                  +--------+--------+


                     repeated NumOps times
                    ___________/\___________
                   /                        \

                  +--------+--------+========+
                  | Key idx(16)     | String |
                  +--------+--------+========+
                </artwork>
              </figure>
            </t>

            <t>
              Detail of an operation with an opcode of 0x3 (KVSto):

              <figure>
                <artwork>
                  0        1
                  +--------+--------+
                  |00000011| NumOps |
                  +--------+--------+


                  repeated NumOps times
                    _______/\______
                   /               \

                  +========+========+
                  | String | String |
                  +========+========+
                </artwork>
              </figure>
            </t>

            <t>
              Detail of an operation with an opcode of 0x4 (Eref):

              <figure>
                <artwork>
                  0        1
                  +--------+--------+
                  |00000100| NumOps |
                  +--------+--------+


                  repeated NumOps times
                    _______/\______
                   /               \

                  +========+========+
                  | String | String |
                  +========+========+
                </artwork>
              </figure>
            </t>


            <t>Each header name must have at least one value.  Header names are encoded using the <xref target="ASCII">US-ASCII character set</xref> and must be all lower case.  The length of each name must be greater than zero.  A recipient of a zero-length name MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the status code PROTOCOL_ERROR for the stream-id.</t>

            <t>Duplicate header names are allowed, but discouraged, except when encoding a cookie or set-cookie.</t>

            <section title="Compression" anchor="Compression">
              <t>The Name/Value Header Block is a section of the SYN_STREAM, SYN_REPLY, and HEADERS frames used to carry header meta-data.  This block is always compressed using zlib compression.  Within this specification, any reference to 'zlib' is referring to the <xref target="RFC1950">ZLIB Compressed Data Format Specification Version 3.3 as part of RFC1950.</xref></t>

              <t>For each HEADERS compression instance, the initial state is initialized using the following <xref target="UDELCOMPRESSION">dictionary</xref>:</t>

              <figure>
                <artwork>
                  Request 1 (for index.html):
                  SYN_STREAM 1, stream-group (G)=0
                  Header-block:
                  Store(0x1): level(C),index(0),k: ":method"
                  Store(0x1): level(C),index(0),v: "GET"
                  Store(0x1): level(C),index(1),k: ":version"
                  Store(0x1): level(C),index(1),v: "HTTP/1.1"
                  Store(0x1): level(C),index(2),k: "user-agent"
                  Store(0x1): level(C),index(2),v: "blah blah browser version blah blah"
                  Store(0x1): level(C),index(3),k: "accept-encoding"
                  Store(0x1): level(C),index(3),v: "sdch, bzip, compress"
                  Store(0x1): level(G),index(0),k: ":host"
                  Store(0x1): level(G),index(0),v: "www.foo.com"
                  Store(0x1): level(G),index(1),k: "cookie"
                  Store(0x1): level(G),index(1),v: "SOMELONGSTRINGTHATISMOSTLYOPAQUE;BLAJHBLA"
                  Store(0x1): level(G),index(2),k: ":path"
                  Store(0x1): level(G),index(2),v: "/index.html"
                  Store(0x1): level(G),index(3),k: "date"
                  Store(0x1): level(G),index(3),v: "Wed Jul 18 11:50:43 2012"

                  At this point the connection headers table looks like this:
                  0: ":method", "GET"
                  1: ":version", "HTTP/1.1"
                  2: "user-agent", "blah blah browser version blah blah"
                  3: "accept-encoding", "sdch, bzip, compress"

                  The stream-group table for group zero looks like this:
                  0: ":host", "www.foo.com"
                  1: "cookie", "SOMELONGSTRINGHTATISMOSTLYOPAQUE;BLAJHBLA"
                  2: ":path", "/index.html"
                  3: "date", "Wed Jul 18 11:50:43 2012"

                  Request 1 (on stream 1) would look like the following if forwarded on HTTP/1.1:
                  GET /index.html HTTP/1.1
                  host: www.foo.com
                  date: Wed Jul 18 11:50:43 2012
                  cookie: SOMELONGSTRINGTHATISMOSTLYOPAQUE;BLAJHBLA
                  user-agent: blah blah browser version blah blah
                  accept-encoding: sdch, bzip, compress


                  Request 2 (for index.js):
                  SYN_STREAM 3, stream-group (G)=0
                  Header-block:
                  Store(0x1): level(G),index(2),v: "/index.js"
                  Store(0x1): level(G),index(3),v: "Wed Jul 18 11:50:44 2012"

                  At this point the connection headers table is unchanged:
                  0: ":method", "GET"
                  1: ":version", "HTTP/1.1"
                  2: "user-agent", "blah blah browser version blah blah"
                  3: "accept-encoding", "sdch, bzip, compress"

                  The stream-group table for group zero looks like this:
                  0: ":host", "www.foo.com"
                  1: "cookie", "SOMELONGSTRINGHTATISMOSTLYOPAQUE;BLAJHBLA"
                  2: ":path", "/index.js"
                  3: "date", "Wed Jul 18 11:50:44 2012"
                  Both the path and the date have changed.

                  Request 2 (on stream 3) would look like the following if forwarded on HTTP/1.1:
                  GET /index.js HTTP/1.1
                  host: www.foo.com
                  date: Wed Jul 18 11:50:44 2012
                  cookie: SOMELONGSTRINGTHATISMOSTLYOPAQUE;BLAJHBLA
                  user-agent: blah blah browser version blah blah
                  accept-encoding: sdch, bzip, compress


                  Request 3 (for index.css):
                  SYN_STREAM 5, stream-group (G)=0
                  Header-block:
                  Store(0x1): level(G),index(2),v: "/index.css"
                  Store(0x1): level(G),index(3),v: "Wed Jul 18 11:50:44 PDT 2012"

                  Connection level-headers are implied.
                  Stream-group level headers are implied.

                  For this example, using TaCo (truncate and concatenate) wasn't useful.
                  If the user, however, changes the cookie on the next request...

                  Request 3 (for somepage.html):
                  SYN_STREAM 5, stream-group (G)=0
                  Header-block:
                  Store(0x1): level(G),index(2),v: "/somepage.html"
                  TaCo(0x1): level(G),index(1),v,TruncTo(40),"FOOBLA"

                  At this point the connection headers table remains unchanged.
                  0: ":method", "GET"
                  1: ":version", "HTTP/1.1"
                  2: "user-agent", "blah blah browser version blah blah"
                  3: "accept-encoding", "sdch, bzip, compress"

                  The stream-group table for group zero looks like this:
                  0: ":host", "www.foo.com"
                  1: "cookie", "SOMELONGSTRINGHTATISMOSTLYOPAQUE;FOOBLA"
                  2: ":path", "/somepate.html"
                  Both the path and the date have changed.

                  Request 3 (on stream 5) would look like the following if forwarded on HTTP/1.1:
                  GET /somepage.html HTTP/1.1
                  host: www.foo.com
                  date: Wed Jul 18 11:50:44 2012
                  cookie: SOMELONGSTRINGTHATISMOSTLYOPAQUE;FOOBLA
                  user-agent: blah blah browser version blah blah
                  accept-encoding: sdch, bzip, compress

                </artwork>
              </figure>
            </section>

          </section>
        </section>
      </section>

      <section anchor="HTTPLayer" title="HTTP Layering over SPDY">
        <t>SPDY is intended to be as compatible as possible with current web-based applications. This means that, from the perspective of the server business logic or application API, the features of HTTP are unchanged. To achieve this, all of the application request and response header semantics are preserved, although the syntax of conveying those semantics has changed.  Thus, the rules from the <xref target="RFC2616">HTTP/1.1 specification in RFC2616</xref> apply with the changes in the sections below.</t>

        <section title="Connection Management">
          <t>Clients SHOULD NOT open more than one SPDY session to a given <xref target="RFC6454">origin</xref> concurrently.</t>
          <t>Note that it is possible for one SPDY session to be finishing (e.g. a GOAWAY message has been sent, but not all streams have finished), while another SPDY session is starting.</t>
          <section title="Use of GOAWAY">
            <t>SPDY provides a GOAWAY message which can be used when closing a connection from either the client or server.  Without a server GOAWAY message, HTTP has a race condition where the client sends a request (a new SYN_STREAM)  just as the server is closing the connection, and the client cannot know if the server received the stream or not.  By using the last-stream-id in the GOAWAY, servers can indicate to the client if a request was processed or not.</t>

            <t>Note that some servers will choose to send the GOAWAY and immediately terminate the connection without waiting for active streams to finish.  The client will be able to determine this because SPDY streams are determinstically closed.  This abrupt termination will force the client to heuristically decide whether to retry the pending requests.  Clients always need to be capable of dealing with this case because they must deal with accidental connection termination cases, which are the same as the server never having sent a GOAWAY.</t>

            <t>More sophisticated servers will use GOAWAY to implement a graceful teardown. They will send the GOAWAY and provide some time for the active streams to finish before terminating the connection.</t>

            <t>If a SPDY client closes the connection, it should also send a GOAWAY message.  This allows the server to know if any server-push streams were received by the client.</t>

            <t>If the endpoint closing the connection has not received any SYN_STREAMs from the remote, the GOAWAY will contain a last-stream-id of 0.</t>

          </section>
        </section>

        <section title="HTTP Request/Response">
          <section title="Request">
            <t>The client initiates a request by sending a SYN_STREAM frame.  For requests which do not contain a body, the SYN_STREAM frame MUST set the FLAG_FIN, indicating that the client intends to send no further data on this stream.  For requests which do contain a body, the SYN_STREAM will not contain the FLAG_FIN, and the body will follow the SYN_STREAM in a series of DATA frames. The last DATA frame will set the FLAG_FIN to indicate the end of the body.</t>

            <t>The SYN_STREAM Name/Value section will contain all of the HTTP headers which are associated with an HTTP request. The header block in SPDY is mostly unchanged from today's HTTP header block, with the following differences:
              <list>
                <t>The first line of the request is unfolded into name/value pairs like other HTTP headers and MUST be present:
                  <list>
                    <t>":method" - the HTTP method for this request (e.g. "GET", "POST", "HEAD", etc)</t>
                    <t>":path" - the url-path for this url with "/" prefixed. (See <xref target="RFC3986">RFC3986</xref>).  For example, for "http://www.google.com/search?q=dogs" the path would be "/search?q=dogs".</t>
                    <t>":version" - the HTTP version of this request (e.g. "HTTP/1.1")</t>
                  </list>
                </t>
                <t>In addition, the following two name/value pairs must also be present in every request:
                  <list>
                    <t>":host" - the hostport (See <xref target="RFC1738">RFC1738</xref>) portion of the URL for this request (e.g. "www.google.com:1234"). This header is the same as the HTTP 'Host' header. </t>
                    <t>":scheme" - the scheme portion of the URL for this request (e.g. "https"))</t>
                </list></t>
                <t>Header names are all lowercase.</t>
                <t>The Connection, Host, Keep-Alive, Proxy-Connection, and Transfer-Encoding headers are not valid and MUST not be sent.</t>
                <t>User-agents MUST support gzip compression. Regardless of the Accept-Encoding sent by the user-agent, the server may always send content encoded with gzip or deflate encoding.</t>
                <t>If a server receives a request where the sum of the data frame payload lengths does not equal the size of the Content-Length header, the server MUST return a 400 (Bad Request) error.</t>
                <t>POST-specific changes:
                  <list>
                    <t>Although POSTs are inherently chunked, POST requests SHOULD also be accompanied by a Content-Length header.  There are two reasons for this:  First, it assists with upload progress meters for an improved user experience.  But second, we know from early versions of SPDY that failure to send a content length header is incompatible with many existing HTTP server implementations.  Existing user-agents do not omit the Content-Length header, and server implementations have come to depend upon this.</t>
                  </list>
                </t>
              </list>
            </t>

            <t>The user-agent is free to prioritize requests as it sees fit. If the user-agent cannot make progress without receiving a resource, it should attempt to raise the priority of that resource. Resources such as images, SHOULD generally use the lowest priority.</t>

            <t>If a client sends a SYN_STREAM without all of the method, host, path, scheme, and version headers, the server MUST reply with a HTTP 400 Bad Request reply.</t>
          </section>

          <section title="Response">
            <t>The server responds to a client request with a SYN_REPLY frame. Symmetric to the client's upload stream, server will send data after the SYN_REPLY frame via a series of DATA frames, and the last data frame will contain the FLAG_FIN to indicate successful end-of-stream.  If a response (like a 202 or 204 response) contains no body, the SYN_REPLY frame may contain the FLAG_FIN flag to indicate no further data will be sent on the stream.</t>

            <t>
              <list>
                <t>The response status line is unfolded into name/value pairs like other HTTP headers and must be present:
                  <list>
                    <t>":status" - The HTTP response status code (e.g. "200" or "200 OK")</t>
                    <t>":version" - The HTTP response version (e.g. "HTTP/1.1")</t>
                  </list>
                </t>
                <t>All header names must be lowercase.</t>
                <t>The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding headers are not valid and MUST not be sent.</t>
                <t>Responses MAY be accompanied by a Content-Length header for advisory purposes.  (e.g. for UI progress meters)</t>
                <t>If a client receives a response where the sum of the data frame payload lengths does not equal the size of the Content-Length header, the client MUST ignore the content length header.</t>
              </list>
            </t>

            <t>If a client receives a SYN_REPLY without a status or without a version header, the client must reply with a RST_STREAM frame indicating a PROTOCOL ERROR.</t>
          </section>

          <section title="Authentication" anchor="Authentication">
            <t>When a client sends a request to an origin server that requires authentication, the server can reply with a "401 Unauthorized" response, and include a WWW-Authenticate challenge header that defines the authentication scheme to be used.  The client then retries the request with an Authorization header appropriate to the specified authentication scheme.</t>

            <t>There are four options for proxy authentication, Basic, Digest, NTLM and Negotiate (SPNEGO).  The first two options were defined in <xref target="RFC2617">RFC2617</xref>, and are stateless.  The second two options were developed by Microsoft and specified in <xref target="RFC4559">RFC4559</xref>, and are stateful; otherwise known as multi-round authentication, or connection authentication.</t>

            <section title="Stateless Authentication">
              <t>Stateless Authentication over SPDY is identical to how it is performed over HTTP. If multiple SPDY streams are concurrently sent to a single server, each will authenticate independently, similar to how two HTTP connections would independently authenticate to a proxy server.</t>
            </section>

            <section title="Stateful Authentication">
              <t>Unfortunately, the stateful authentication mechanisms were implemented and defined in a such a way that directly violates RFC2617 - they do not include a "realm" as part of the request.  This is problematic in SPDY because it makes it impossible for a client to disambiguate two concurrent server authentication challenges.</t>

              <t>To deal with this case, SPDY servers using Stateful Authentication MUST implement one of two changes:
                <list>
                  <t>Servers can add a "realm=&lt;desired realm&gt;" header so that the two authentication requests can be disambiguated and run concurrently.  Unfortunately, given how these mechanisms work, this is probably not practical.</t>
                  <t>Upon sending the first stateful challenge response, the server MUST buffer and defer all further frames which are not part of completing the challenge until the challenge has completed.  Completing the authentication challenge may take multiple round trips.  Once the client receives a "401 Authenticate" response for a stateful authentication type, it MUST stop sending new requests to the server until the authentication has completed by receiving a non-401 response on at least one stream.</t>
                </list>
              </t>
            </section>
          </section>
        </section>

        <section title="Server Push Transactions">
          <t>SPDY enables a server to send multiple replies to a client for a single request.  The rationale for this feature is that sometimes a server knows that it will need to send multiple resources in response to a single request and would otherwise be forced to inline the images into the document.  Without server push features, the server must inline, or the client must first download the primary resource, then discover the secondary resource(s), and request them.  Pushing of resources avoids the round-trip delay, but also creates a potential race where a server can be pushing content which a user-agent is in the process of requesting.  The following mechanics attempt to prevent the race condition while enabling the performance benefit. Server push is designed to be strictly better than inlining.</t>

          <t>Browsers receiving a pushed response MUST validate that the server is authorized to push the URL using the <xref target="RFC6454">browser same-origin</xref> policy, or by verifying that the server has proven (via SSL handshake or CERTIFICATE frame) that it has the certificate for the domain of the pushed content.  For example, a SPDY connection to www.foo.com is generally not permitted to push a response for www.evil.com. A SPDY connection to www.foo.com would be allowed to push images.foo.com, however, assuming the cert provided at the SSL handshake was a wildcard cert encoding *.foo.com</t>

          <t>If the browser accepts a pushed response (e.g. it does not send a RST_STREAM), the browser MUST attempt to cache the pushed response in same way that it would cache any other response.  This means validating the response headers and inserting into the cache.</t>

          <t>Because pushed responses have no request, they have no request headers associated with them.  At the framing layer, SPDY pushed streams contain an "associated-stream-id" which indicates the requested stream for which the pushed stream is related.  The pushed stream inherits all of the headers from the associated-stream-id with the exception of ":host", ":scheme", and ":path", which are provided as part of the pushed response stream headers.  The browser MUST store these inherited and implied request headers with the cached resource.</t>

          <t>Implementation note:  Similarly with inlining, with server push it is theoretically possible for servers to push large amounts of content or resources to the user-agent.  Browsers MUST implement throttles to protect against unreasonable push attacks, just as they must react reasonably to abuse of inlining. The server-push mechanism should make this easier to deal with than inlining in basically every case.</t>

          <section title="Server implementation">
            <t>When the server intends to push a resource to the user-agent, it promises that it will opens a new stream in the future (but not now) by sending a PUSH_PROMISE frame.  The PUSH_PROMISE frame MUST include an Associated-To-Stream-ID, Prmoised-Stream-ID, and MUST ensure that headers for ":scheme", ":host", ":path" representing the URL for the resource being pushed are either already present in the implied headers context (i.e. the request headers), or it must override the headers which do not match the pushed resource. The ":path" MUST always be different from the originally request resource.  The stream-IDs represented in the Promised-Stream-ID field MUST NOT count towards the MAX_CONCURRENT_STREAMS limit. When the server is ready to send the resource, it will send a SYN_REPLY with the stream-ID indicated by the Promised-Stream-ID send in the PUSH_PROMISE frame earlier. As with any other SYN_REPLY, subsequent headers may follow in HEADERS frames. The purpose of the association is so that the user-agent can differentiate which request induced the pushed stream; without it, if the user-agent had two tabs open to the same page, each pushing unique content under a fixed URL, the user-agent would not be able to differentiate the requests.</t>

            <t>The Associated-To-Stream-ID must be the ID of an existing, open stream.  The reason for this restriction is to have a clear endpoint for pushed content.  If the user-agent requested a resource on stream 11, the server replies on stream 11.  It can push any number of additional streams to the client before sending a FLAG_FIN on stream 11.  However, once the originating stream is closed no further push streams may be associated with it.  The pushed streams do not need to be closed (FIN set) before the originating stream is closed, they only need to be created before the originating stream closes.</t>

            <t>To prevent a race condition with the client, the server must only use the client certificate of the associated stream when pushing resources.</t>

            <t>It is illegal for a server to push a resource with the Associated-To-Stream-ID of 0, or with a Slot that is not 0.</t>

            <t>To minimize race conditions with the client, the SYN_STREAM for the pushed resources MUST be sent prior to sending any content which could allow the client to discover the pushed resource and request it.</t>

            <t>The server MUST only push resources which would have been returned from a GET request.</t>

            <t>Note:  If the server does not have all of the Name/Value Response headers available at the time it issues the HEADERS frame for the pushed resource, it may later use an additional HEADERS frame to augment the name/value pairs to be associated with the pushed stream.  The subsequent HEADERS frame(s) must not contain a header for ':host', ':scheme', or ':path' (e.g. the server can't change the identity of the resource to be pushed).  The HEADERS frame must not contain duplicate headers with a previously sent HEADERS frame.  The server must send a HEADERS frame including the scheme/host/port headers before sending any data frames on the stream.</t>
          </section>

          <section title="Client implementation">
            <t>When fetching a resource the client has 3 possibilities:
              <list>
                <t>the resource is not being pushed</t>
                <t>the resource is being pushed, but the data has not yet arrived</t>
                <t>the resource is being pushed, and the data has started to arrive</t>
              </list>
            </t>

            <t>When a SYN_STREAM and HEADERS frame which contains an Associated-To-Stream-ID is received, the client must not issue GET requests for the resource in the pushed stream, and instead wait for the pushed stream to arrive.  </t>

            <t>If a client receives a server push stream with stream-id 0, it
              MUST issue a <xref target="SessionErrorHandler">session error</xref> with the status code PROTOCOL_ERROR.</t>

            <t>When a client receives a SYN_STREAM from the server without a the ':host', ':scheme', and ':path' headers in the Name/Value section, it MUST reply with a RST_STREAM with error code HTTP_PROTOCOL_ERROR.</t>

            <t>To cancel individual server push streams, the client can issue a <xref target="StreamErrorHandler">stream error</xref> with error code CANCEL.  Upon receipt, the server MUST stop sending on this stream immediately (this is an Abrupt termination).</t> 

            <t>To cancel all server push streams related to a request, the client may issue a <xref target="StreamErrorHandler">stream error</xref> with error code CANCEL on the associated-stream-id.  By cancelling that stream, the server MUST immediately stop sending frames for any streams with in-association-to for the original stream.</t>

            <t>If the server sends a HEADER frame containing duplicate headers with a previous HEADERS frame for the same stream, the client must issue a <xref target="StreamErrorHandler">stream error</xref> with error code PROTOCOL ERROR.</t>

            <t>If the server sends a HEADERS frame after sending a data frame for the same stream, the client MAY ignore the HEADERS frame.  Ignoring the HEADERS frame after a data frame prevents handling of HTTP's trailing headers (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.40).</t>
          </section>
        </section>

      </section>

      <section anchor="WebSocketLayer" title="WebSocket Layering over SPDY">
        <t>With this layering, a client and sever can share one connection for both of HTTP requests and WebSockets.</t>
        <section title="Connection Management">
          <section title="Opening Handshake">
            <section title="Handshake Request">
              <t>The client initiates an opening handshake by sending a SYN_STREAM frame. The SYN_STREAM frame MUST NOT set the FLAG_FIN because WebSocket intends to establish a bi-directional communication port and to send arbitrary data after success in opening handshake.</t>

              <t>The SYN_STREAM Name/Value section will contain all of the following headers which are associated with <xref target="RFC6455">The WebSocket protocol</xref> opening handshake. Upgrade, Connection, Sec-WebSocket-Key, and Sec-WebSocket-Version headers MUST NOT be included because we do not have to take care of protocol upgrading or verification over HTTP.</t>

              <t>The following name/value pairs MUST be present in every request:</t>
              <list>
                <t>“:path” - /resource name/ as used in the “Client Requirements” section of the WebSocket protocol specification. (See <xref target="RFC6455">RFC6455</xref>)</t>
                <t>“:host” - /host:port/ (e.g. “www.google.com:1234”) as used in the “Client Requirements” section of the WebSocket protocol specification. (See <xref target="RFC6455">RFC6455</xref>)</t>
                <t>“:version” - the WebSocket protocol version of this request. (MUST be “WebSocket/8”, “WebSocket/13”, or so. The number MUST be matched with the Sec-WebSocket-Version header. See <xref target="RFC6455">RFC6455</xref>)</t>
                <t>“:scheme” - the scheme portion of the URI. (MUST be “ws” or “wss”. See also /secure/ flag in <xref target="RFC6455">RFC6455</xref>)</t>
                <t>“:origin” - /origin/ as used in the “Client Requirements” section of the WebSocket protocol specification. (See <xref target="RFC6455">RFC6455</xref>)</t>
              </list>

              <t>In addition, the following OPTIONAL name/value pairs MAY be present:</t>
              <list>
                <t>“:sec-websocket-protocol” - the Sec-WebSocket-Protocol header (See <xref target="RFC6455">RFC6455</xref>)</t>
                <t>“:sec-websocket-extensions” - the Sec-WebSocket-Extensions header (See <xref target="RFC6455">RFC6455</xref>)</t>
              </list>

              <t>Also, other HTTP compatible header name/value pairs MAY be present. All header keys MUST be lowercase.</t>
            </section>
            <section title="Handshake Response">
              <t>The server responds to a client request with a SYN_REPLY frame. If the server intends to allow the client connection, SYN_REPLY frame MUST NOT set the FLAG_FIN and MUST have “:status” containing “101”. But, an unsuccessful response MUST set the FLAG_FIN and MUST have “:status” containing non-”101” code. The server MAY fail the opening handshake because of an unexpected header value or a missing mandatory header name.</t>

              <t>The client MAY send some data to the server before receiving the successful response. The server MUST ignore this data when opening handshake fails. After sending successful response, the server can send arbitrary data frames at any time.</t>

              <t>The response status line is unfolded into name/value pairs like other WebSocket headers and MUST be present:</t>
              <list>
                <t>“:status” - The WebSocket or fallback HTTP response status code (e.g. “101” or “101 Switching Protocols”. See <xref target="RFC6455">RFC6455</xref>)</t>
              </list>

              <t>In addition, the following OPTIONAL name/value pairs MAY be present:</t>
              <list>
                <t>“:sec-websocket-protocol” - the Sec-WebSocket-Protocol header (See <xref target="RFC6455">RFC6455</xref>)</t>
                <t>“:sec-websocket-extensions” - the Sec-WebSocket-Extensions header (See <xref target="RFC6455">RFC6455</xref>)</t>
              </list>

              <t>Also, other HTTP compatible header name/value pairs MAY be present. All header names MUST be lowercase. The successful server response MUST have “:status” containing “101”.</t>

              <t>If the handshake fails, the client MUST send a SPDY data frame with empty data field to avoid abnormal SPDY session termination. The SPDY data frame MUST set the FLAG_FIN to indicate the client intends to send no further data on this stream.</t>
            </section>
          </section>
          <section title="Closing Handshake">
            <section title="Normal Termination">
              <t>In normal termination, WebSocket connection close frame <xref target="RFC6455">RFC6455</xref> will be sent as a SPDY data frame with FLAG_FIN set. The closing handshake is based on WebSocket protocol specification. Both of a server and a client will initiate it then the other end MUST respond it by connection close frame with FLAG_FIN set.</t>
            </section>

            <section title="Abnormal Termination and CloseEvent Handling">

              <t>In abnormal termination, RST_STREAM SHOULD be handled as connection close frame. It means that JavaScript API provides CloseEvent (See, <xref target="WEBSOCKETAPI">The WebSocket API</xref>) when a client receives RST_STREAM. Its code field SHOULD be 1006 (Abnormal Closure). The GOAWAY control frame with non-zero status code SHOULD be also handled in the same way. The status code of RST_STREAM and GOAWAY frames SHOULD be encoded to UTF-8 string with its frame type for its reason field. (e.g. “SPDY/3 RST_STREAM (5)” or “SPDY/3 GOAWAY (1)”)</t>
              <t>If a server works as protocol bridge to the WebSocket protocol, it MAY send a close frame which contains the above status code and the above reason to a backend WebSocket server.</t>
            </section>
          </section>
        </section>
        <section title="Bi-directional Communication">

          <t>After the opening handshake, the client and the server can send arbitrary WebSocket control and data frames. Continuation frame, text frame, binary frame, connection close frame, ping frame, and pong frame are valid WebSocket frames. These WebSocket frames are mapped into each SPDY HEADERS frame and DATA frames as follow.</t>
          <section title="Frame mapping">

            <t>One WebSocket frame is mapped into one proceeding SPDY HEADERS frame and following plural SPDY data frames. The SPDY HEADERS frame must contain WebSocket frame fields and following SPDY data frames contain payload data. These data frames are free to be reframed.</t>
            <t>This plan doesn’t care about overheads. But HEADERS frame are compressed by shared dictionary with other SYN_STREAM, SYN_REPLY, and other HEADERS in the same SPDY connection. Optimistically, it reduces framing overheads.</t>

            <t>The following name/value pairs MUST be present in SPDY HEADERS frames:</t>
            <list>
              <t>“:opcode” - The WebSocket frame opcode (See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>“:length” - The WebSocket frame payload length in decimal (See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>“:fin” - The WebSocket frame fin (See <xref target="RFC6455">RFC6455</xref>)</t>
            </list>

            <t>In addition, the following OPTIONAL name/value pairs MAY be present:</t>
            <list>
              <t>“:rsv1” - The WebSocket frame rsv1</t>
              <t>“:rsv2” - The WebSocket frame rsv2</t>
              <t>“:rsv3” - The WebSocket frame rsv3 (See <xref target="RFC6455">RFC6455</xref>). These values must contain “0” or “1”. When a key doesn’t exist, the value is considered to be “0”. Thus, ony enabled bits may appear here.</t>
              <t>“:masking-key” - The WebSocket frame masking-key (See <xref target="RFC6455">RFC6455</xref>) in hexadecimal (e.g. “deadbeaf”). When this key/value exist, the WebSocket frame mask (See <xref target="RFC6455">RFC6455</xref>) is considered to be 1 and following payload data MUST be masked(See <xref target="RFC6455">RFC6455</xref>), otherwise the WebSocket frame mask is considered to be 0.</t>
            </list>
          </section>
        </section>
      </section>

      <section title="Design Rationale and Notes">
        <t>Authors' notes:  The notes in this section have no bearing on the SPDY protocol as specified within this document, and none of these notes should be considered authoritative about how the protocol works.  However, these notes may prove useful in future debates about how to resolve protocol ambiguities or how to evolve the protocol going forward.  They may be removed before the final draft.</t>

        <section title="Separation of Framing Layer and Application Layer">
          <t>Readers may note that this specification sometimes blends the <xref target="FramingLayer">framing layer</xref> with requirements of a specific application - <xref target="HTTPLayer">HTTP</xref>.  This is reflected in the request/response nature of the streams, the definition of the HEADERS and compression contexts which are very similar to HTTP, and other areas as well.</t>

          <t>This blending is intentional - the primary goal of this protocol is to create a low-latency protocol for use with HTTP.  Isolating the two layers is convenient for description of the protocol and how it relates to existing HTTP implementations.  However, the ability to reuse the SPDY framing layer is a non goal.</t>
        </section>

        <section title="Error handling - Framing Layer">
          <t>Error handling at the SPDY layer splits errors into two groups:  Those that affect an individual SPDY stream, and those that do not.</t>

          <t>When an error is confined to a single stream, but general framing is in tact, SPDY attempts to use the RST_STREAM as a mechanism to invalidate the stream but move forward without aborting the connection altogether.</t>

          <t>For errors occuring outside of a single stream context, SPDY assumes the entire session is hosed.  In this case, the endpoint detecting the error should initiate a connection close.</t>
        </section>
        <section title="One Connection Per Domain">
          <t>SPDY attempts to use fewer connections than other protocols have traditionally used.  The rationale for this behavior is because it is very difficult to provide a consistent level of service (e.g. TCP slow-start), prioritization, or optimal compression when the client is connecting to the server through multiple channels.</t>

          <t>Through lab measurements, we have seen consistent latency benefits by using fewer connections from the client.  The overall number of packets sent by SPDY can be as much as 40% less than HTTP.  Handling large numbers of concurrent connections on the server also does become a scalability problem, and SPDY reduces this load.</t>

          <t>The use of multiple connections is not without benefit, however.  Because SPDY multiplexes multiple, independent streams onto a single stream, it creates a potential for head-of-line blocking problems at the transport level.  In tests so far, the negative effects of head-of-line blocking (especially in the presence of packet loss) is outweighed by the benefits of compression and prioritization.</t>
        </section>
        <section title="Fixed vs Variable Length Fields">
          <t>SPDY favors use of fixed length 32bit fields in cases where smaller, variable length encodings could have been used.  To some, this seems like a tragic waste of bandwidth.  SPDY choses the simple encoding for speed and simplicity.</t>

          <t>The goal of SPDY is to reduce latency on the network.  The overhead of SPDY frames is generally quite low.  Each data frame is only an 8 byte overhead for a 1452 byte payload (~0.6%).  At the time of this writing, bandwidth is already plentiful, and there is a strong trend indicating that bandwidth will continue to increase.  With an average worldwide bandwidth of 1Mbps, and assuming that a variable length encoding could reduce the overhead by 50%, the latency saved by using a variable length encoding would be less than 100 nanoseconds.  More interesting are the effects when the larger encodings force a packet boundary, in which case a round-trip could be induced.  However, by addressing other aspects of SPDY and TCP interactions, we believe this is completely mitigated.</t>
        </section>
        <section title="Compression Context(s)">
          <t>When isolating the compression contexts used for communicating with multiple origins, we had a few choices to make.  We could have maintained a map (or list) of compression contexts usable for each origin.  The basic case is easy - each HEADERS frame would need to identify the context to use for that frame.  However, compression contexts are not cheap, so the lifecycle of each context would need to be bounded.  For proxy servers, where we could churn through many contexts, this would be a concern.  We considered using a static set of contexts, say 16 of them, which would bound the memory use.  We also considered dynamic contexts, which could be created on the fly, and would need to be subsequently destroyed.  All of these are complicated, and ultimately we decided that such a mechanism creates too many problems to solve.</t>

          <t>Alternatively, we've chosen the simple approach, which is to simply provide a flag for resetting the compression context.  For the common case (no proxy), this fine because most requests are to the same origin and we never need to reset the context.  For cases where we are using two different origins over a single SPDY session, we simply reset the compression state between each transition.</t>
        </section>
        <section title="Unidirectional streams">
          <t>Besides providing a clear endpoint for unidirectional streams, Associated-To-Stream-ID also avoids the recipient of pushed streams from needing to send a set of empty frames (e.g. the SYN_STREAM w/ FLAG_FIN) to signal that it doesn't wish to send data on the stream.</t>
        </section>
        <section title="Data Compression">
          <t>Generic compression of data portion of the streams (as opposed to compression of the headers) without knowing the content of the stream is redundant.  There is no value in compressing a stream which is already compressed.  Because of this, SPDY initially allowed data compression to be optional.  We included it because study of existing websites shows that many sites are not using compression as they should, and users suffer because of it.  We wanted a mechanism where, at the SPDY layer, site administrators could simply force compression - it is better to compress twice than to not compress.</t>

          <t>Overall, however, with this feature being optional and sometimes redundant, it was unclear if it was useful at all.  We removed it from the specification.</t>
        </section>
        <section title="Server Push">
          <t>A subtle but important point is that server push streams must be declared before the associated stream is closed.  The reason for this is so that proxies have a lifetime for which they can discard information about previous streams.  If a pushed stream could associate itself with an already-closed stream, then endpoints would not have a specific lifecycle for when they could disavow knowledge of the streams which went before.</t>
        </section>
      </section>

      <section title="Security Considerations">
        <section title="Use of Same-origin constraints">
          <t>This specification uses the <xref target="RFC6454">same-origin policy</xref> in all cases where verification of content is required.</t>
        </section>

        <section title="HTTP Headers and SPDY Headers">
          <t>At the application level, HTTP uses name/value pairs in its headers.  Because SPDY merges the existing HTTP headers with SPDY headers, there is a possibility that some HTTP applications already use a particular header name.  To avoid any conflicts, all headers introduced for layering HTTP over SPDY are prefixed with ":".  ":" is not a valid sequence in HTTP header naming, preventing any possible conflict.</t>
        </section>

        <section title="Cross-Protocol Attacks">
          <t>By utilizing TLS, we believe that SPDY introduces no new cross-protocol attacks.  TLS encrypts the contents of all transmission (except the handshake itself), making it difficult for attackers to control the data which could be used in a cross-protocol attack.</t>
        </section>

        <section title="Server Push Implicit Headers">
          <t>Pushed resources do not have an associated request.  In order for existing HTTP cache control validations (such as the Vary header) to work, however, all cached resources must have a set of request headers.  For this reason, browsers MUST be careful to inherit request headers from the associated stream for the push.  This includes the 'Cookie' header.</t>
        </section>
      </section>

      <section title="Privacy Considerations">
        <section title="Long Lived Connections">
          <t>SPDY aims to keep connections open longer between clients and servers in order to reduce the latency when a user makes a request.  The maintenance of these connections over time could be used to expose private information.  For example, a user using a browser hours after the previous user stopped using that browser may be able to learn about what the previous user was doing.  This is a problem with HTTP in its current form as well, however the short lived connections make it less of a risk.</t>
        </section>

        <section title="SETTINGS frame">
          <t>The SPDY SETTINGS frame allows servers to store out-of-band transmitted information about the communication between client and server on the client.  Although this is intended only to be used to reduce latency, renegade servers could use it as a mechanism to store identifying information about the client in future requests.</t>

          <t>Clients implementing privacy modes, such as Google Chrome's "incognito mode", may wish to disable client-persisted SETTINGS storage.</t>

          <t>Clients MUST clear persisted SETTINGS information when clearing the cookies.</t>

          <t>TODO: Put range maximums on each type of setting to limit inappropriate uses.</t>
        </section>
      </section>

      <section title="Sub-protocol negotiation">
        <section title="Supporting scheme negotiation using SETTINGS frame">

          <t>By default, a client can send SYN_STREAM frames on http and https schemes, but if it want to send them on other schemes, it MUST wait for a server sending SETTINGS frame which specify declaring schemes. Thus, a server SHOULD send a SETTINGS frame as soon as possible whether it supports other schemes or not.</t>

        </section>
      </section>

      <section title="Incompatibilities with SPDY draft #3">
        <t>
          Here is a list of the major changes between this draft #3 and this draft
          <list>

            <t>DONE: Different, more precise, notation style used to describe all frames.</t>
            <t>DONE: Downsizing various fields in all messages... this will definitely need debate</t>
            <t>DONE: Removal of Version field from all messages.</t>
            <t>DONE: Reordered fields in all messages. All messages now share a common header of: length, flags, control-bit, 31-bit-payload. All control frames include an 8th byte, which is the opcode.</t>
            <t>DONE: Addition of end-of-message delimiter flag in data frames</t>
            <t>DONE: Modification of server push; addition of PUSH_PROMISE frame add a push frame, removed the 'associated-stream-id' field from SYN frame</t>

            <t>ONGOING: Significant modifications to how headers are transported. This involved changes to all frames incorporating HEADER blocks, and changes to the HEADER blocks themselves.</t>
            <t>ONGOING: Different header compression technique which uses less CPU for proxies and which should result in competitive compression</t>
            <t>TODO: Addition of end-of-header-section delimiter flag in any frame which has a header block</t>

            <t>ONGOING: Definition of cert-data push</t>
            <t>ONGOING: Definition of name-resolution push</t>
            <t>ONGOING: Redefining prioritization</t>

            <t>TODO: Modification of flow-control; allow two-levels of flow control so as to allow greater stream concurrency safely</t>
            <t>TODO: Add the 'blocked-on-flow-control' notification. Experience has shown that limits are too easy to get wrong, and this helps to self-correct this problem</t>
            <t>TODO: Modification of flow-control; headers-blocks (thus syn-stream) gets its own pool of memory, separate from data frames</t>
            <t>TODO: Everything after the first header-block-section possibly treated as flow-control</t>
            <t>TODO: Session-error status code added for UNRECOGNIZED_SCHEME for new streams. This triggers when the recipient doesn't know how to handle a stream of that type.</t>

          </list>
        </t>
      </section>

      <section title="Requirements Notation">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
          document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
      </section>

      <section title="Acknowledgements">
        <t>
          Many individuals have contributed to the design and evolution of SPDY:
          Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk,
          Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth,
          Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer,
          Fan Yang, Jonathan Leighton, Alex Strom
        </t>
      </section>
    </middle>

    <back>
      <references title="Normative References">
        &RFC0793;
        &RFC1738;
        &RFC1950;
        &RFC2119;
        &RFC2285;
        &RFC2616;
        &RFC2617;
        &RFC3986;
        &RFC4559;
        &RFC4366;
        &RFC5246;
        &RFC6454;
        &RFC6455;
        <reference anchor="TLSNPN" target="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-01">
          <front>
            <title>TLS Next Protocol Negotiation</title>
            <author initials="A." surname="Langley"> <organization/> </author>
          </front>
        </reference>
        <reference anchor="ASCII">
          <front>
            <title>US-ASCII. Coded Character Set - 7-Bit American Standard Code for Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.</title>
          </front>
        </reference>
        <reference anchor="UDELCOMPRESSION" target="http://www.eecis.udel.edu/~amer/PEL/poc/pdf/SPDY-Fan.pdf">
          <front>
            <title>A Methodology to Derive SPDY’s Initial Dictionary for Zlib Compression</title>
            <author initials="F." surname="Yang"></author>
            <author initials="P." surname="Amer"></author>
            <author initials="J." surname="Leighton"></author>
          </front>
        </reference>
        <reference anchor="WEBSOCKETAPI" target="http://www.w3.org/TR/websockets/">
          <front>
            <title>The WebSocket API</title>
            <author initials="I." surname="Hickson"> <organization/> </author>
          </front>
        </reference>
      </references>
      <section title="Changes">
        <t>To be removed by RFC Editor before publication</t>
      </section>
    </back>
  </rfc>

